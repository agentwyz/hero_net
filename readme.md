![pho1.png(43)](E:\系统默认\下载\pho1.png(43).png)这个是一个关于hero-net的文档:

hero net采用了reactor这个网络编程模式

1. 三个基本角色: reactor, handler, acceptor
2. 三类基本事件: 读事件, 写事件, 连接事件

```
os -----> javacode ---> user api
```


操作系统底层使用IO多路复用机制, linux使用的是epoll机制, 这种机制使得我们可以充分利用线程
linux使用这种机制, 完成了对socket的可读可写的监听, **epoll是不是多线程的**

epoll在内核中使用红黑树跟踪进程中所有待测的文件描述字, 将所有需要监听的socket插入到红黑树中, 当红黑树中有对应的事件触发
那么只需要将该事件放入到对应的链表中。


我们只需要在框架中设计对应的抽象, 然后从操作系统中拿到对应的socket信息。

首先我们最先设计的组件是Net组件, 这个组件位于整个网络框架的初始状态, 同时它的生命周期一般会经历
初始状态INITIAL, 运行状态, 和对应的退出状态, 我们通过一个LifeCycle和一个abstractCycle两个类进行控制

其次, 我们需要弄明白线程中产生交互的范围, 

1. 监听服务端的socket的主线程和处理读/写事件的工作线程之间存在交互, 因为主线程需要在accept()方法调用完成, 连接建立成功之后, 
   将socket对象绑定到一个特定的工作线程上面, 比如读的socket, 绑定到读线程上面 

2. 除此之外, 我们的用户线程可能会与工作线程产生交互, 比如我们想要在某个连接中发送消息, 或者强制去关闭某个连接, 
   这都需要我们与工作线程进行通信

所以我们需要给我们的工作线程设置一个队列,用于接收来自外界的消息, 所以工作线程不仅仅需要监听操作系统事件以外, 还需要检索队列并响应外部信息

之后, 我们的项目还需要涉及到临界区访问的问题, 其中比较典型的socket事件注册状态的修改, 在我们这个框架中一个socket在多路复用的状态可以会被多个线程修改
关于事件的修改状态, 所以我们需要一把锁, 这把锁可以帮助我们锁住对应的对象。

直接内存通过Arena类来进行申请, 返回MemorySegment对象, 该对象可以看作是C语言的一个指针
Arena分配内存主要有两种方式: 1. openConfined()和Arena.openShared()两种

第一种方式, 只能由申请内存的线程进行访问


给每一条TCP连接分别安排一个专门为其处理事件的对象
Poller--->PollerNode ---> sentry
Writer--->WriterNode ---> proto



Sentry ---> PollerNode ---> ProtoNode ---> xxx


使用`epoll_ctl()`函数将需要监控的socket加入到内核的红黑树中,
在该网络框架中, 我们使用ctl修改我们的状态, 注册状态, 这样当有可读状态之后就会给我们响应


使用Poller创建的工作线程就是一个完整的epoll过程




在TCP连接中, 其实是分为两个阶段的第一个阶段就是Sentry这个阶段, 这个阶段就是用来监视TCP连接上的这个初始化认证阶段
进行的怎么样了, 开发者需要在Sentry上去注册对应的回调事件, 来判断什么时候可以进入下一个阶段。


> 假如现在有三个连接, 第一个连接是读事件, 第二个连接是写事件, 第三个连接是写事件, 



